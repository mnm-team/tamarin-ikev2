/*
 * Protocol:	IKEv2
 * Modeler:	Tobias Heider & Stefan-Lukas Gazdag
 * Date:	04/2019
 * Status:	in work
 */

theory IKEv2
begin

builtins: asymmetric-encryption, diffie-hellman, symmetric-encryption, hashing, signing

// IKEv2 Protocol

/*
 * Ephemeral Diffie Hellman Key generator and oracle
 */
rule generate_dh:
	[ Fr(~e) ]
	--[ DH_generated($U) ]->
	[ DHt($U, ~e, 'g'^~e) ]

rule dh_oracle:
	[ DHt($U, e, ep) ]
	--[DHreveal($U)]->
	[ DH($U, e, ep), Out(e) ]

/*
 * Static Longterm Key generator
 */
rule generate_static:
	[ Fr(~ltk) ]
	-->
	[ !Ltk($U, ~ltk, pk(~ltk)) ]

rule static_oracle:
	[ !Ltk($U, ltk, pk(ltk)) ]
	--[LeakStatic($U, ltk)]->
	[ Out(ltk) ]

/*
 * IKEv2 Protocol transitions
 */
rule IKE_SA_INIT_I:
	[ DH($I, eI, epI)
	, Fr(~nI)
	, Fr(~spiI)
	]
	--[ Initiated($I) ]->
	[
	/*
	 * HDR, SAi1, KEi, Ni  -->
	 */
	  Out(<$I, ~spiI, '1', epI, ~nI>)
	, IKE_SA_INIT_I($I, ~spiI, eI, ~nI, <$I, '1', epI, ~nI>)
	]

rule IKE_SA_INIT_R:
let
	/*
	 * Generate Keying Material
	 *
	 * In IKEv2 keys are read bytewise from a procedural generated byte
	 * output. In the model we have no concept of bytes, thus each key
	 * is a single block.
	 */
	k = epI^eR
	skeyseed = h(<nI, ~nR>, k)
	S = <nI, ~nR, $I, $R>
	sk_d = h(skeyseed, <S, '1'>)
	sk_ai = h(skeyseed, <sk_d, S, '2'>)
	sk_ar = h(skeyseed, <sk_ai, S, '3'>)
	sk_ei = h(skeyseed, <sk_ar, S, '4'>)
	sk_er = h(skeyseed, <sk_ei, S, '5'>)
	sk_pi = h(skeyseed, <sk_er, S, '6'>)
	sk_pr = h(skeyseed, <sk_pi, S, '7'>)
	keymat = <sk_d, sk_ai, sk_ar, sk_ei, sk_er, sk_pi, sk_pr>

	/*
	 * Messages for auth hash
	 */
	msg1 = <$I, spiI, '1', epI, nI> 
	msg2 = <$I, $R, spiI, ~spiR, '2', epR, ~nR>
in
	[
	/*
	 * HDR, SAi1, KEi, Ni  -->
	 */
	  In(msg1)
	/*
	 * Generate DH keys, Nonce and SPI
	 */
	, DH($R, eR, epR)
	, Fr(~nR)
	, Fr(~spiR)
	]
	--[ SessKey($I, $R, keymat)
	  , Initiated($R)
	  ]->
	[
	/*
	 * <--  HDR, SAr1, KEr, Nr
	 */
	  Out(msg2)
	, IKE_SA_INIT_R($I, $R, spiI, ~spiR, nI, ~nR, keymat, msg1, msg2)
	]

rule IKE_AUTH_I:
let
	/*
	 * Generate Keying Material
	 *
	 * In IKEv2 keys are read bytewise from a procedural generated byte
	 * output. In the model we have no concept of bytes, thus each key
	 * is a single block.
	 */
	k = epR^eI
	skeyseed = h(<nI, nR>, k)
	S = <nI, nR, $I, $R>
	sk_d = h(skeyseed, <S, '1'>)
	sk_ai = h(skeyseed, <sk_d, S, '2'>)
	sk_ar = h(skeyseed, <sk_ai, S, '3'>)
	sk_ei = h(skeyseed, <sk_ar, S, '4'>)
	sk_er = h(skeyseed, <sk_ei, S, '5'>)
	sk_pi = h(skeyseed, <sk_er, S, '6'>)
	sk_pr = h(skeyseed, <sk_pi, S, '7'>)
	keymat = <sk_d, sk_ai, sk_ar, sk_ei, sk_er, sk_pi, sk_pr>

	/*
	 * Authentication and validity of IKE_SA_INIT
	 */
	signed_octets = <msg1, nR, h(~idI, sk_pi)>
	auth_pl = sign(signed_octets, ltk)

	/*
	 * Encryption and Integrity
	 */
	encr_pl = <senc(~idI, sk_ei), senc(auth_pl, sk_ei), senc(pk, sk_ei)> /* SK {IDi, AUTH, SAi2, TSi, TSr} */
	integ = h(<$I, $R, spiI, spiR, '3', encr_pl>, sk_ai)
in
	[
	/*
	 * <--  HDR, SAr1, KEr, Nr
	 */
	  In(<$I, $R, spiI, spiR, '2', epR, nR>)
	, IKE_SA_INIT_I($I, spiI, eI, nI, msg1)
	, Fr(~idI)
	, !Ltk($I, ltk, pk)
	]
	--[
		SessKeys($I, $R, keymat)
	]->
	[
	/*
	 * HDR, SK {IDi, AUTH, SAi2, TSi, TSr}  -->
	 */
	  Out(<$I, $R, spiI, spiR, '3', encr_pl, integ>)
	, IKE_AUTH_I($I, $R, spiI, spiR, nI, nR, keymat, msg1, <$I, $R, spiI, spiR, '2', epR, nR>, ltk, pk)
	]

rule IKE_AUTH_R:
let 
	/*
	 * Messages for auth hash
	 */
	msg1 = <$I, spiI, '1', epI, nI> 
	msg2 = <$I, $R, spiI, spiR, '2', epR, nR>

	keymat = <sk_d, sk_ai, sk_ar, sk_ei, sk_er, sk_pi, sk_pr>

	/*
	 * Incoming Payloads
	 */
	auth_pl_I = sdec(auth_enc_I, sk_ei)
	idI = sdec(id_enc_I, sk_ei)
	pkI = sdec(pk_enc_I, sk_ei)
	signed_octets_I = <msg1, nR, h(idI, sk_pi)>

	/*
	 * Outgoing Payloads
	 */
	signed_octets_R = <msg2, nI, h(~idR, sk_pr)>
	auth_pl_R = sign(signed_octets_R, ltkR)
	encr_pl_R = <senc(~idR, sk_er), senc(auth_pl_R, sk_er), senc(pkR, sk_er)>
	integ_R = h(<$I, $R, spiI, spiR, '3', encr_pl_R>, sk_ar)
in
	[
	  In(<$I, $R, spiI, spiR, '3', <id_enc_I, auth_enc_I, pk_enc_I>, integ_I>)
	, IKE_SA_INIT_R($I, $R, spiI, spiR, nI, nR, keymat, msg1, msg2)
	, Fr(~idR)
	, !Ltk($R, ltkR, pkR)
	]
	--[ Eq(h(<$I, $R, spiI, spiR, '3', <id_enc_I, auth_enc_I, pk_enc_I>>, sk_ai), integ_I)
	  , Eq(verify(auth_pl_I, signed_octets_I, pkI), true)
	  , Authenticated($I, idI)
	  ]->
	[
	/*
	 * <-- HDR, SK {IDr, AUTH, SAr2, TSi, TSr}
	 */
	  Out(<$I, $R, spiI, spiR, '4', encr_pl_R, integ_R>)
	]

rule IKE_AUTH_I2:
let
	keymat = <sk_d, sk_ai, sk_ar, sk_ei, sk_er, sk_pi, sk_pr>

	/*
	 * Incoming Payloads
	 */
	auth_pl_R = sdec(auth_enc_R, sk_er)
	idR = sdec(id_enc_R, sk_er)
	pkR = sdec(pk_enc_R, sk_er)
	signed_octets_R = <msg2, nI, h(idR, sk_pr)>

in
	[
	  In(<$I, $R, spiI, spiR, '4', <id_enc_R, auth_enc_R, pk_enc_R>, integ_R>)
	, IKE_AUTH_I($I, $R, spiI, spiR, nI, nR, keymat, msg1, msg2, ltkI, pkI)
	]
	--[ Eq(h(<$I, $R, spiI, spiR, '4', <id_enc_R, auth_enc_R, pk_enc_R>>, sk_ar), integ_R)
	  , Eq(verify(auth_pl_R, signed_octets_R, pkR), true)
	  , Authenticated($R, idR)
	  ]->
	[
	  
	]

restriction Eq_check_succeed: "All x y #i. Eq(x,y) @ i ==> x = y"

lemma key:
	"
	not (
		Ex I R keymat #i #j.
		/* client has set up a session key 'k' with a server'S' */
		SessKeys(I, R, keymat) @ #i
		/* and the adversary knows 'k' */
		& K(keymat) @ #j
		& not (Ex #r . DHreveal(I) @ #r)
	)
	"

lemma authenticated:
	"
	not( Ex I id #i . Authenticated(I, id) @ #i )
	"

lemma authenticated_secret:
	"
	not ( Ex I R idI idR keymat #i #j #r .
		Authenticated(I, idI) @ #i
		& Authenticated(R, idR) @ #j
		& K(keymat) @ #r
	)
	"

lemma init:
	"
	Ex U #i . Initiated(U) @ #i
	"

lemma dh_generated:
	"
	not (Ex U #i . DH_generated(U) @ #i)
	"

lemma session_key:
	"
	Ex I R keymat #i . SessKeys(I, R, keymat) @ #i
	"

end
